// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroInput.cs - 네트워크 입력 데이터 구조체
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 개요 (Overview)                                                                                      │
// │                                                                                                       │
// │ 이 파일은 클라이언트에서 서버로 전송되는 입력 데이터를 정의합니다.                                    │
// │ MOBA 게임에 필요한 모든 입력 정보(스킬 버튼, 클릭 위치, 타겟 등)를 담습니다.                         │
// │                                                                                                       │
// │ 핵심 기술:                                                                                            │
// │ 1. INetworkInput 인터페이스 - Fusion 입력 시스템                                                     │
// │ 2. NetworkButtons - 버튼 상태 비트 플래그                                                            │
// │ 3. NetworkId - 네트워크 오브젝트 참조                                                                │
// │ 4. 클라이언트 예측 - 입력이 서버로 전송되고 검증됨                                                   │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 설계 철학 (Design Philosophy)                                                                        │
// │                                                                                                       │
// │ Q: 왜 struct인가요? class가 아니라?                                                                  │
// │ A: struct는 값 타입으로:                                                                              │
// │    - 스택에 할당 → GC 부담 없음 (매 틱마다 생성되므로 중요)                                          │
// │    - 복사 시 전체 값 복사 → 히스토리 관리 용이                                                       │
// │    - Fusion 내부에서 효율적으로 직렬화                                                               │
// │                                                                                                       │
// │ Q: 왜 INetworkInput 인터페이스를 구현하나요?                                                         │
// │ A: Fusion의 입력 시스템과 통합하기 위해.                                                              │
// │    - Runner.SetInputProvider()로 입력 제공자 등록                                                    │
// │    - GetInput<HeroInput>()으로 입력 읽기                                                             │
// │    - 입력 히스토리 자동 관리 (롤백/재시뮬레이션용)                                                   │
// │                                                                                                       │
// │ Q: NetworkButtons vs bool[]?                                                                         │
// │ A: NetworkButtons는 내부적으로 비트 플래그:                                                           │
// │    - 6개 버튼 = 6비트 = 1바이트 미만                                                                  │
// │    - bool[] = 6바이트 + 배열 오버헤드                                                                │
// │    - 네트워크 대역폭 크게 절약                                                                       │
// │    - IsSet(), WasPressed() 등 편의 메서드 제공                                                       │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 입력 처리 흐름 (Input Flow)                                                                          │
// │                                                                                                       │
// │ [클라이언트]                                                                                          │
// │ 1. Update()에서 키보드/마우스 입력 감지                                                               │
// │ 2. OnInput() 콜백에서 HeroInput 구조체 생성                                                           │
// │ 3. input.Set() 호출로 Fusion에 전달                                                                  │
// │                                                                                                       │
// │ [Fusion 네트워크 레이어]                                                                              │
// │ 4. 입력 데이터를 서버로 전송                                                                         │
// │ 5. 입력 히스토리 저장 (롤백용)                                                                       │
// │                                                                                                       │
// │ [서버]                                                                                                │
// │ 6. FixedUpdateNetwork()에서 GetInput<HeroInput>() 호출                                               │
// │ 7. 입력에 따라 게임 로직 처리                                                                        │
// │ 8. 결과를 [Networked] 변수에 저장 → 클라이언트 동기화                                                │
// │                                                                                                       │
// │ [클라이언트 예측]                                                                                     │
// │ 9. 클라이언트도 로컬에서 같은 입력으로 시뮬레이션 (지연 없는 느낌)                                   │
// │ 10. 서버 결과와 다르면 롤백 후 재시뮬레이션                                                          │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════

using Fusion;
using UnityEngine;

// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// InputButton 열거형 - 입력 버튼 정의
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// NetworkButtons와 함께 사용:
// - Buttons.IsSet(InputButton.SkillQ) → Q키 눌림 여부
// - Buttons.WasPressed(previousButtons, InputButton.SkillQ) → Q키 새로 눌림 여부
//
// enum 값 (0~5):
// - 내부적으로 비트 인덱스로 사용
// - SkillQ = 0 → 비트 0 (0b000001)
// - SkillW = 1 → 비트 1 (0b000010)
// - LeftClick = 4 → 비트 4 (0b010000)
// - RightClick = 5 → 비트 5 (0b100000)
//
// 확장 가능:
// - Shift, Ctrl 등 수정자 키 추가 가능
// - 아이템 단축키 (1~6) 추가 가능
// - 소환사 주문 (D, F) 추가 가능
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
public enum InputButton
{
    SkillQ,      // Q 스킬 (투사체)
    SkillW,      // W 스킬 (범위)
    SkillE,      // E 스킬 (지속)
    SkillR,      // R 스킬 (궁극기)
    LeftClick,   // 좌클릭 (기본 공격 / 스킬 시전)
    RightClick,  // 우클릭 (이동)
}

// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroInput 구조체 - 네트워크 입력 데이터
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// INetworkInput:
// - Fusion의 입력 시스템 인터페이스
// - 이 인터페이스를 구현해야 Runner.GetInput<T>() 사용 가능
// - 마커 인터페이스 (메서드 없음)
//
// 매 네트워크 틱마다:
// - 클라이언트: 새 HeroInput 생성 → 서버로 전송
// - 서버: 받은 HeroInput으로 게임 로직 처리
//
// 메모리 레이아웃 (대략):
// - NetworkButtons: 4바이트 (비트 플래그)
// - Vector3 × 3: 36바이트
// - PlayerRef: 4바이트
// - NetworkId: 4바이트
// - 총: ~48바이트 (매 틱마다 전송)
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
public struct HeroInput : INetworkInput
{
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // Buttons - 버튼 입력 상태
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // NetworkButtons:
    // - Fusion 제공 구조체
    // - 내부적으로 비트 플래그 (uint)
    // - 최대 32개 버튼 지원
    //
    // 사용 예:
    // - 버튼 설정: buttons.Set(InputButton.SkillQ, Input.GetKey(KeyCode.Q))
    // - 버튼 확인: buttons.IsSet(InputButton.SkillQ)
    // - 새 입력: buttons.WasPressed(prevButtons, InputButton.SkillQ)
    //
    // WasPressed vs IsSet:
    // - IsSet: 현재 눌려있는지 (계속 true)
    // - WasPressed: 이번 틱에 새로 눌렸는지 (한 번만 true)
    // - 스킬은 WasPressed 사용 (한 번 발동)
    // - 이동은 IsSet 사용 (계속 이동)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    public NetworkButtons Buttons;

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // 위치 데이터
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // HitPosition_RightClick:
    // - 우클릭 시 마우스 레이캐스트 월드 좌표
    // - 이동 목적지로 사용
    // - 서버에서 NavMeshAgent.SetDestination()에 전달
    //
    // HitPosition_Skill:
    // - 스킬 사용 시 마우스 레이캐스트 월드 좌표
    // - 스킬 방향, 범위 스킬 위치에 사용
    // - Eva Q: 투사체 발사 방향
    // - Eva W: 범위 스킬 중심점
    //
    // MousePosition:
    // - 화면 좌표계 마우스 위치
    // - UI 상호작용, 디버그에 사용
    // - 월드 좌표 변환 필요 시 Camera.ScreenToWorldPoint()
    //
    // 왜 2개의 HitPosition?
    // - 우클릭(이동)과 스킬이 동시에 발생할 수 있음
    // - 스킬 사용 중 우클릭 이동 → 각각 다른 위치
    // - 분리해서 저장해야 혼선 없음
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    public Vector3 HitPosition_RightClick;
    public Vector3 HitPosition_Skill;

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // 플레이어 식별
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // Owner (PlayerRef):
    // - 이 입력을 보낸 플레이어
    // - 서버에서 입력 권한 검증에 사용
    // - Runner.LocalPlayer와 비교
    //
    // PlayerRef:
    // - Fusion의 플레이어 식별자
    // - int로 변환 가능 (내부적으로 정수)
    // - Runner.TryGetPlayerObject(playerRef)로 오브젝트 찾기
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    public PlayerRef Owner;
    public Vector3 MousePosition;

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // TargetNetworkId - 클릭한 대상의 네트워크 ID
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // 사용 시나리오:
    // - 적 캐릭터 클릭 시 기본 공격 타겟 지정
    // - 미니언 클릭 시 공격 대상 지정
    // - 아군 클릭 시 버프/힐 대상 지정
    //
    // NetworkId:
    // - NetworkObject의 고유 식별자
    // - 서버/클라이언트 모두 같은 ID 사용
    // - Runner.TryFindObject(networkId, out var obj)로 찾기
    //
    // 왜 GameObject 참조가 아닌 NetworkId?
    // - GameObject 참조는 네트워크 전송 불가
    // - NetworkId는 4바이트 정수로 전송 가능
    // - 서버에서 NetworkId로 실제 오브젝트 찾기
    //
    // 기본값:
    // - NetworkId.None (타겟 없음)
    // - 땅 클릭 시 타겟 없음
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    public NetworkId TargetNetworkId;  // 클릭한 적 ID
}
