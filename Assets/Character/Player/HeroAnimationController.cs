// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroAnimationController.cs - 모든 영웅의 애니메이션 기본 컨트롤러
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 개요 (Overview)                                                                                      │
// │                                                                                                       │
// │ 이 파일은 모든 영웅이 공유하는 기본 애니메이션 기능을 제공합니다.                                     │
// │ 이동 속도 동기화, 사망 애니메이션 등 공통 기능을 구현합니다.                                         │
// │                                                                                                       │
// │ 핵심 기술:                                                                                            │
// │ 1. Animator 파라미터 동기화 - MoveSpeed를 네트워크로 동기화                                          │
// │ 2. Event 기반 통신 - Movement → AnimationController 단방향                                           │
// │ 3. Render()에서 애니메이션 적용 - 매 렌더 프레임 부드러운 전환                                       │
// │ 4. RPC 사망 처리 - 모든 클라이언트에서 동시에 사망 애니메이션                                        │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 설계 철학 (Design Philosophy)                                                                        │
// │                                                                                                       │
// │ Q: 왜 Movement의 이벤트를 구독하나요?                                                                │
// │ A: 컴포넌트 간 결합도를 낮추기 위해.                                                                  │
// │    AnimationController가 Movement를 직접 참조하면:                                                    │
// │    - Movement 변경 시 AnimationController도 수정해야 함                                               │
// │    - 순환 참조 위험                                                                                   │
// │    이벤트 방식은:                                                                                     │
// │    - Movement가 "속도 바뀜" 이벤트만 발생                                                             │
// │    - AnimationController가 필요한 것만 구독                                                           │
// │                                                                                                       │
// │ Q: 왜 MoveVelocity가 [Networked]인가요?                                                              │
// │ A: 다른 플레이어 화면에서 내 캐릭터의 걷기/달리기를 볼 수 있어야 함.                                  │
// │    네트워크 동기화 없으면 원격 플레이어는 항상 Idle 상태로 보임.                                      │
// │                                                                                                       │
// │ Q: 왜 Render()에서 애니메이션을 적용하나요?                                                          │
// │ A: FixedUpdateNetwork()는 네트워크 틱마다 실행 (20~60Hz).                                            │
// │    Render()는 렌더 프레임마다 실행 (60~144Hz).                                                        │
// │    애니메이션은 렌더 프레임에 맞춰야 부드럽게 보임.                                                   │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 상속 구조 (Inheritance Hierarchy)                                                                    │
// │                                                                                                       │
// │ NetworkBehaviour (Fusion)                                                                            │
// │        │                                                                                              │
// │        └── HeroAnimationController (이 파일)                                                          │
// │                      │                                                                                │
// │                      ├── Eva_AnimationController  (Q,W,E,R 스킬 애니메이션 RPC)                      │
// │                      ├── Aya_AnimationController  (미래 캐릭터)                                       │
// │                      └── Rio_AnimationController  (미래 캐릭터)                                       │
// │                                                                                                       │
// │ Eva_AnimationController 예시:                                                                        │
// │ - RPC_Multi_Skill_Q() - Q 스킬 애니메이션                                                            │
// │ - RPC_Multi_BasicAttack() - 기본 공격 애니메이션                                                     │
// │ - RPC_Multi_CancelSkillAnimation() - 스킬 캔슬 애니메이션                                            │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════

using Fusion;
using UnityEngine;

// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroAnimationController 클래스
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// 역할:
// - 이동 애니메이션 동기화 (MoveSpeed 파라미터)
// - 사망 애니메이션 RPC 제공
// - 자식 클래스에 animator 참조 제공
//
// 컴포넌트 의존성:
// - Animator: 애니메이션 컨트롤러 (필수)
// - HeroMovement: 이동 속도 이벤트 제공
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
public class HeroAnimationController : NetworkBehaviour
{
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // 컴포넌트 참조
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // [SerializeField] protected:
    // - Inspector에서 할당 가능
    // - 자식 클래스에서 접근 가능
    // - 외부에서 접근 불가
    //
    // animator:
    // - Unity의 Mecanim 애니메이션 시스템
    // - State Machine 기반 애니메이션 전환
    // - SetFloat(), SetTrigger() 등으로 파라미터 제어
    //
    // movement:
    // - HeroMovement 컴포넌트 참조
    // - OnMoveVelocityChanged 이벤트 구독용
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [SerializeField] protected Animator animator;
    protected HeroMovement movement;

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // [Networked] MoveVelocity - 이동 속도 동기화
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // 왜 int인가요?
    // - 0: Idle (정지)
    // - 1: Walk (걷기)
    // - 2: Run (달리기)
    // - float보다 네트워크 대역폭 절약
    // - Animator의 MoveSpeed 파라미터와 매핑
    //
    // 동기화 흐름:
    // 1. HeroMovement에서 이동 속도 변경
    // 2. OnMoveVelocityChanged 이벤트 발생
    // 3. 이 클래스에서 MoveVelocity 값 업데이트
    // 4. [Networked]라 자동으로 모든 클라이언트에 동기화
    // 5. Render()에서 Animator에 적용
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Networked] protected int MoveVelocity {get; set;}

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // Spawned() - 네트워크 오브젝트 생성 시 호출
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // 초기화 작업:
    // 1. HeroMovement 컴포넌트 가져오기
    // 2. 이동 속도 변경 이벤트 구독
    // 3. MoveVelocity 초기값 설정 (Idle)
    //
    // 이벤트 구독 패턴:
    // - movement.OnMoveVelocityChanged += OnChangedVelocity
    // - Movement가 속도 변경 시 이 클래스의 OnChangedVelocity 자동 호출
    // - 결합도 낮춤 (Movement는 AnimationController 몰라도 됨)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    public override void Spawned()
    {
        movement = GetComponent<HeroMovement>();
        movement.OnMoveVelocityChanged += OnChangedVelocity;

        MoveVelocity = 0;
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // Render() - 매 렌더 프레임 호출
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // Render() vs FixedUpdateNetwork():
    // - FixedUpdateNetwork(): 네트워크 틱마다 (시뮬레이션)
    // - Render(): 렌더 프레임마다 (비주얼)
    //
    // 왜 Render()에서 애니메이션 적용?
    // - 애니메이션은 비주얼 요소
    // - 렌더 프레임에 맞춰야 부드러움
    // - 네트워크 틱은 20~60Hz로 느림
    // - 렌더 프레임은 60~144Hz로 빠름
    //
    // SetFloat("MoveSpeed", value):
    // - Animator의 MoveSpeed 파라미터 설정
    // - Blend Tree에서 Idle/Walk/Run 애니메이션 블렌딩에 사용
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    public override void Render()
    {
        if (animator)
        {
            if (movement)
            {
                animator.SetFloat("MoveSpeed", MoveVelocity);
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // OnChangedVelocity() - 이동 속도 변경 이벤트 핸들러
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // 호출 시점:
    // - HeroMovement.OnMoveVelocityChanged 이벤트 발생 시
    // - 이동 시작/정지/속도 변경 시
    //
    // 파라미터 v:
    // - 0: Idle
    // - 1: Walk
    // - 2: Run
    //
    // MoveVelocity = v:
    // - [Networked] 변수 업데이트
    // - 자동으로 모든 클라이언트에 동기화
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    private void OnChangedVelocity(int v)
    {
        MoveVelocity = v;
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // RPC_DeadProcess() - 사망 애니메이션 RPC
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // [Rpc] 어트리뷰트:
    // - RpcSources.StateAuthority: 서버(Host)에서만 호출 가능
    // - RpcTargets.All: 모든 클라이언트에서 실행
    // - HostMode.SourceIsServer: 호스트 모드에서 서버가 소스
    //
    // 호출 흐름:
    // 1. Eva_State.OnTakeDamage()에서 HP <= 0 감지
    // 2. GetComponent<Eva_AnimationController>().RPC_DeadProcess() 호출
    // 3. 모든 클라이언트에서 이 함수 실행
    // 4. 각 클라이언트에서 사망 애니메이션 재생
    //
    // 처리 내용:
    // - MoveVelocity = 0: 이동 애니메이션 정지
    // - SetTrigger("IsDead"): 사망 애니메이션 트리거
    //
    // 왜 RPC인가?
    // - 사망 애니메이션은 1회성 이벤트
    // - 모든 클라이언트에서 동시에 재생해야 함
    // - [Networked] 상태 변수보다 RPC가 적절
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_DeadProcess()
    {
        if (animator)
        {
            MoveVelocity = 0;
            animator.SetTrigger("IsDead");
        }
    }
}
