// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroState.cs - 모든 영웅의 기본 상태 관리 (HP, 스탯 등)
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 개요 (Overview)                                                                                      │
// │                                                                                                       │
// │ 이 파일은 모든 영웅이 공유하는 기본 상태(HP 등)를 정의하는 베이스 클래스입니다.                       │
// │ Eva_State, Aya_State 등 각 영웅의 State 클래스가 이를 상속받습니다.                                  │
// │                                                                                                       │
// │ 핵심 기술:                                                                                            │
// │ 1. [Networked] 변수 - 서버/클라이언트 자동 동기화                                                    │
// │ 2. 상속 구조 - 공통 기능은 부모에, 영웅별 기능은 자식에                                              │
// │ 3. protected 접근 제한자 - 자식 클래스만 접근 가능                                                   │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 설계 철학 (Design Philosophy)                                                                        │
// │                                                                                                       │
// │ Q: 왜 NetworkBehaviour를 상속하나요?                                                                 │
// │ A: HP, 스탯 등이 [Networked] 변수로 네트워크 동기화되어야 하기 때문.                                  │
// │    NetworkBehaviour가 아니면 [Networked] 어트리뷰트 사용 불가.                                        │
// │                                                                                                       │
// │ Q: 왜 CurrHealth를 protected로 선언하나요?                                                           │
// │ A: 외부에서 직접 HP를 변경하면 데미지 로직 우회 가능.                                                 │
// │    반드시 OnTakeDamage() 등 정해진 경로로만 변경해야 함.                                              │
// │    자식 클래스(Eva_State)에서는 접근 가능해야 하므로 protected.                                       │
// │                                                                                                       │
// │ Q: 왜 GetCurrHealth()를 public으로 제공하나요?                                                       │
// │ A: HP UI 표시 등 읽기 전용 접근은 필요함.                                                             │
// │    Setter 없이 Getter만 제공해서 읽기만 허용.                                                         │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 상속 구조 (Inheritance Hierarchy)                                                                    │
// │                                                                                                       │
// │ NetworkBehaviour (Fusion)                                                                            │
// │        │                                                                                              │
// │        └── HeroState (이 파일)                                                                        │
// │                 │                                                                                     │
// │                 ├── Eva_State  (IDamageProcess 구현)                                                 │
// │                 ├── Aya_State  (미래 캐릭터)                                                          │
// │                 └── Rio_State  (미래 캐릭터)                                                          │
// │                                                                                                       │
// │ 장점:                                                                                                 │
// │ - CurrHealth, MaxHealth 등 공통 변수 중복 제거                                                       │
// │ - 영웅별 특수 상태(Eva의 빛 게이지 등)는 자식 클래스에 추가                                          │
// │ - 새 영웅 추가 시 HeroState 상속만 하면 기본 HP 시스템 완성                                          │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════

using Character.Player;
using Fusion;
using Fusion.Addons.SimpleKCC;
using UnityEngine;
using UnityEngine.AI;

// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroState 클래스
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// 역할:
// - 모든 영웅의 기본 상태 변수 정의 (CurrHealth, MaxHealth)
// - 네트워크 동기화 보장 ([Networked])
// - 자식 클래스에 공통 기능 제공
//
// 사용 예:
// class Eva_State : HeroState, IDamageProcess
// {
//     public void OnTakeDamage(float damage)
//     {
//         CurrHealth -= damage;  // 부모의 protected 변수 접근
//     }
// }
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
public class HeroState : NetworkBehaviour
{
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // [Networked] 상태 변수
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // [Networked] 어트리뷰트:
    // - 이 변수가 변경되면 Fusion이 자동으로 모든 클라이언트에 동기화
    // - 서버에서만 변경 가능 (StateAuthority)
    // - 클라이언트에서 변경해도 서버 값으로 덮어씀
    //
    // [field:SerializeField]:
    // - Unity Inspector에서 값 확인 가능 (디버깅용)
    // - 자동 구현 프로퍼티에 SerializeField 적용하는 문법
    //
    // protected:
    // - 자식 클래스(Eva_State 등)에서만 접근 가능
    // - 외부 클래스에서 직접 HP 조작 방지
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Networked] [field:SerializeField]
    protected float CurrHealth {get; set;}

    [Networked] [field:SerializeField]
    protected float MaxHealth {get; set;}

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // Spawned() - 네트워크 오브젝트 생성 시 호출
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // 호출 시점:
    // - Runner.Spawn() 이후 네트워크 초기화 완료 시
    // - 서버와 모든 클라이언트에서 호출됨
    //
    // 왜 Start()가 아닌 Spawned()인가?
    // - Start()는 네트워크 초기화 전에 호출될 수 있음
    // - [Networked] 변수는 Spawned() 이후에야 안전하게 사용 가능
    // - Fusion의 NetworkBehaviour 생명주기를 따라야 함
    //
    // 현재 구현:
    // - MaxHealth = 10000 (테스트용 높은 값)
    // - CurrHealth = MaxHealth (풀피로 시작)
    // - 실제 게임에서는 캐릭터별 스탯 데이터에서 로드해야 함
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    public override void Spawned()
    {
        MaxHealth = 10000;
        CurrHealth = MaxHealth;
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // GetCurrHealth() - HP 읽기 전용 접근자
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // 왜 public Getter만 제공하나요?
    // - HP UI, 상태바 등에서 현재 HP를 읽어야 함
    // - 하지만 외부에서 직접 CurrHealth = 100 같이 설정하면 안 됨
    // - Getter만 제공해서 읽기 전용으로 만듦
    //
    // HP 변경은 반드시:
    // - OnTakeDamage() 메서드를 통해 (데미지)
    // - Heal() 메서드를 통해 (회복) - 미구현
    // - 이렇게 해야 데미지 감소, 보호막 등 추가 로직 적용 가능
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    public float GetCurrHealth()
    {
        return CurrHealth;
    }
}
