// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// ClickAnimation.cs - 클릭 VFX 페이드 애니메이션
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 개요 (Overview)                                                                                      │
// │                                                                                                       │
// │ 이 파일은 클릭 위치에 표시되는 VFX(파티클)의 페이드 아웃 애니메이션을 처리합니다.                     │
// │ 우클릭 이동 명령 시 나타나는 "클릭 이펙트"가 서서히 사라지게 합니다.                                 │
// │                                                                                                       │
// │ 핵심 기술:                                                                                            │
// │ 1. DOTween - Unity 애니메이션 라이브러리 (부드러운 보간)                                              │
// │ 2. Material.DOColor - 머티리얼 색상/투명도 트위닝                                                    │
// │ 3. ParticleSystem - Unity 파티클 시스템                                                              │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 설계 철학 (Design Philosophy)                                                                        │
// │                                                                                                       │
// │ Q: 왜 DOTween을 사용하나요?                                                                          │
// │ A: Unity 기본 Animator보다 코드로 제어하기 쉬움.                                                       │
// │    - 간단한 페이드: mat.DOColor(color, 1f) 한 줄                                                     │
// │    - Animator: State Machine 설정, Clip 생성, Parameter 등 복잡                                      │
// │    일회성 간단한 애니메이션에 DOTween이 효율적.                                                       │
// │                                                                                                       │
// │ Q: 왜 부모와 자식 머티리얼을 모두 처리하나요?                                                        │
// │ A: 클릭 VFX가 여러 파트로 구성되어 있을 수 있음.                                                       │
// │    - 부모: 메인 파티클                                                                                │
// │    - 자식: 추가 이펙트 (빛, 원 등)                                                                    │
// │    모두 동시에 페이드해야 자연스러움.                                                                 │
// │                                                                                                       │
// │ Q: 왜 Start()에서 바로 애니메이션을 시작하나요?                                                       │
// │ A: 이 오브젝트는 클릭할 때마다 새로 생성됨 (Instantiate).                                              │
// │    생성 즉시 페이드 아웃 시작 → 1초 후 사라짐.                                                        │
// │    별도의 트리거 필요 없음.                                                                          │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ DOTween 사용법 (Quick Reference)                                                                     │
// │                                                                                                       │
// │ 색상 트위닝:                                                                                          │
// │ material.DOColor(targetColor, duration);           // 기본 색상                                      │
// │ material.DOColor(targetColor, "_Color", duration); // 특정 프로퍼티                                   │
// │                                                                                                       │
// │ 알파 (투명도) 트위닝:                                                                                 │
// │ material.DOFade(0f, duration);  // 완전 투명으로                                                     │
// │                                                                                                       │
// │ 체이닝:                                                                                               │
// │ material.DOColor(...).OnComplete(() => Destroy(gameObject));                                         │
// │                                                                                                       │
// │ 이징:                                                                                                 │
// │ material.DOColor(...).SetEase(Ease.OutQuad);  // 끝에서 감속                                         │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════

using UnityEngine;
using DG.Tweening;

// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// ClickAnimation 클래스
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// 역할:
// - 클릭 VFX의 머티리얼 투명도를 1초에 걸쳐 0으로 페이드
// - 부모 파티클과 모든 자식 렌더러의 머티리얼 처리
//
// 사용법:
// - 클릭 VFX 프리팹에 이 스크립트 부착
// - Instantiate 후 자동으로 페이드 시작
//
// 관련 파일:
// - HeroMovement.cs: 우클릭 시 이 VFX 스폰
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
public class ClickAnimation : MonoBehaviour
{
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // 머티리얼 참조
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // particleSystem:
    // - 이 오브젝트의 ParticleSystem 컴포넌트
    //
    // particleMaterial:
    // - 부모 파티클의 머티리얼 (런타임 인스턴스)
    //
    // childMaterials:
    // - 모든 자식 렌더러의 머티리얼 배열
    //
    // 왜 .material을 사용하나요? (sharedMaterial 아닌)
    // - .material: 런타임 복사본 생성, 이 인스턴스만 영향
    // - .sharedMaterial: 원본 에셋, 모든 인스턴스에 영향
    // - 여러 클릭 이펙트가 동시에 존재할 수 있으므로 개별 머티리얼 필요
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    private ParticleSystem particleSystem;
    private Material particleMaterial;
    private Material[] childMaterials;

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // Start() - 초기화 및 애니메이션 시작
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    private void Start()
    {
        // 부모의 ParticleSystem 초기화
        InitParticleSystem();

        // 자식 오브젝트의 Material 초기화
        InitChildMaterials();

        // ═══════════════════════════════════════════════════════════════════════════════════════════════
        // 부모 머티리얼 페이드 애니메이션
        // ═══════════════════════════════════════════════════════════════════════════════════════════════
        //
        // DOColor(targetColor, propertyName, duration):
        // - targetColor: 목표 색상 (현재 색상에서 알파만 0으로)
        // - "_Color": 셰이더의 색상 프로퍼티 이름
        // - 1f: 1초 동안 트위닝
        //
        // new Color(r, g, b, 0f):
        // - 기존 RGB 유지, 알파만 0 (완전 투명)
        // ═══════════════════════════════════════════════════════════════════════════════════════════════
        if (particleMaterial != null)
        {
            Color startColor = particleMaterial.color;
            particleMaterial.DOColor(new Color(startColor.r, startColor.g, startColor.b, 0f), "_Color", 1f);
        }

        // ═══════════════════════════════════════════════════════════════════════════════════════════════
        // 자식 머티리얼 페이드 애니메이션
        // ═══════════════════════════════════════════════════════════════════════════════════════════════
        //
        // foreach로 모든 자식 머티리얼에 동일한 애니메이션 적용
        // 모든 파트가 동시에 페이드되어 자연스러움
        // ═══════════════════════════════════════════════════════════════════════════════════════════════
        foreach (Material mat in childMaterials)
        {
            if (mat != null)
            {
                Color startColor = mat.color;
                mat.DOColor(new Color(startColor.r, startColor.g, startColor.b, 0f), "_Color", 1f);
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // InitParticleSystem() - 부모 파티클 시스템 초기화
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // GetComponent<ParticleSystem>():
    // - 이 오브젝트의 ParticleSystem 가져오기
    //
    // GetComponent<Renderer>().material:
    // - ParticleSystem의 렌더러에서 머티리얼 가져오기
    // - .material은 런타임 복사본 생성
    //
    // null 체크:
    // - 파티클 시스템이 없거나 렌더러가 없을 수 있음
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    private void InitParticleSystem()
    {
        particleSystem = GetComponent<ParticleSystem>();
        if (particleSystem != null && particleSystem.GetComponent<Renderer>() != null)
        {
            particleMaterial = particleSystem.GetComponent<Renderer>().material;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // InitChildMaterials() - 자식 렌더러 머티리얼 초기화
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // GetComponentsInChildren<Renderer>():
    // - 이 오브젝트와 모든 자식의 Renderer 가져오기
    // - MeshRenderer, ParticleSystemRenderer 등 모두 포함
    //
    // .material 접근:
    // - 각 렌더러의 런타임 머티리얼 복사본 가져오기
    // - 원본에 영향 없이 개별 제어 가능
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    private void InitChildMaterials()
    {
        Renderer[] childRenderers = GetComponentsInChildren<Renderer>();
        childMaterials = new Material[childRenderers.Length];

        for (int i = 0; i < childRenderers.Length; i++)
        {
            childMaterials[i] = childRenderers[i].material;
        }
    }
}
