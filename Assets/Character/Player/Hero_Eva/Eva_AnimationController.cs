// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// Eva_AnimationController.cs - Eva 캐릭터의 애니메이션 동기화
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 개요 (Overview)                                                                                      │
// │                                                                                                       │
// │ 이 파일은 Eva 캐릭터의 애니메이션을 네트워크 동기화하는 역할을 합니다.                                │
// │ 서버에서 스킬을 사용하면 RPC로 모든 클라이언트에 애니메이션 재생 명령을 전달합니다.                   │
// │                                                                                                       │
// │ 핵심 기술:                                                                                            │
// │ 1. RPC (Remote Procedure Call) - 서버→클라이언트 함수 호출                                           │
// │ 2. Animator Trigger/Bool - Unity 애니메이션 파라미터 제어                                            │
// │ 3. CrossFade - 애니메이션 블렌딩 (부드러운 전환)                                                     │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 설계 철학 (Design Philosophy)                                                                        │
// │                                                                                                       │
// │ Q: 왜 애니메이션도 RPC로 동기화하나요?                                                               │
// │ A: 스킬 로직은 서버에서만 실행. 클라이언트는 애니메이션만 재생해야 함.                                │
// │    RPC 없으면 서버만 애니메이션 재생 → 다른 플레이어에게 안 보임                                     │
// │                                                                                                       │
// │ Q: Trigger vs Bool 차이점은?                                                                         │
// │ A: Trigger: 한 번 발동 후 자동 리셋 (Q, W 같은 일회성 스킬)                                          │
// │    Bool: 수동 리셋 필요 (E, R 같은 지속 스킬)                                                         │
// │                                                                                                       │
// │ Q: 왜 CrossFade를 사용하나요?                                                                        │
// │ A: 즉시 전환하면 애니메이션이 끊김. CrossFade는 부드럽게 블렌딩.                                     │
// │    캔슬 시 특히 중요 (Q→W 빠른 전환에서 부자연스러움 방지)                                            │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════

using Fusion;
using UnityEngine;

// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// Eva_AnimationController 클래스
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// 상속: HeroAnimationController
// - 모든 영웅의 공통 애니메이션 기능 (Animator 참조 등)
// - NetworkBehaviour를 상속하여 RPC 사용 가능
//
// 애니메이션 트리거 이름 규칙:
// - tSkill01~04: Q, W, E, R 스킬
// - bSkill03, bSkill04: E, R 스킬의 Loop용 Bool
// - tBasicAttack: 기본 공격
// - tCancelAttack: 공격 캔슬
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
public class Eva_AnimationController : HeroAnimationController
{
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // RPC_Multi_Skill_Q() - Q 스킬 애니메이션 (투사체)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // [Rpc] 어트리뷰트 설명:
    // - RpcSources.StateAuthority: 서버(Host)에서만 이 함수 호출 가능
    // - RpcTargets.All: 모든 클라이언트에서 이 함수 실행
    // - HostMode.SourceIsServer: 호스트 모드에서 서버가 소스
    //
    // 결과:
    // 서버에서 RPC_Multi_Skill_Q() 호출 → 모든 클라이언트 animator.SetTrigger("tSkill01") 실행
    //
    // SetTrigger():
    // - Animator 파라미터를 true로 설정
    // - 애니메이션 State Machine이 해당 Transition 감지
    // - 다음 프레임에 자동 false로 리셋
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_Multi_Skill_Q()
    {
        animator.SetTrigger("tSkill01");
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // RPC_Multi_Skill_W() - W 스킬 애니메이션 (범위 스킬)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_Multi_Skill_W()
    {
        animator.SetTrigger("tSkill02");
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // RPC_Multi_Skill_E() - E 스킬 시작 (Loop 애니메이션)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // E 스킬은 지속 스킬이라 Bool 파라미터도 사용:
    // - tSkill03: Trigger - 시작 애니메이션 재생
    // - bSkill03: Bool - Loop 상태 유지
    //
    // 애니메이션 흐름:
    // 1. tSkill03 Trigger → E 스킬 시작 애니메이션 재생
    // 2. bSkill03 = true → Loop 애니메이션으로 전환, 유지
    // 3. RPC_Multi_Skill_E_End() → bSkill03 = false → Loop 종료, 복귀 애니메이션
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_Multi_Skill_E()
    {
        animator.SetTrigger("tSkill03");
        animator.SetBool("bSkill03", true);  // Loop용 bool
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // RPC_Multi_Skill_E_End() - E 스킬 종료
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // E 스킬 지속시간이 끝나면 호출
    // bSkill03 = false로 Loop 해제 → 복귀 애니메이션 재생
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_Multi_Skill_E_End()
    {
        animator.SetBool("bSkill03", false);  // Loop 해제
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // RPC_Multi_Skill_R_Activate_Animation() - R 스킬 활성화 (토글 ON)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // R 스킬은 토글 방식:
    // - 첫 번째 R: 활성화 (이 함수)
    // - 두 번째 R: 비활성화 (RPC_Multi_Skill_R_Deactivate_Animation)
    //
    // E 스킬과 동일한 패턴:
    // - tSkill04: 시작 애니메이션
    // - bSkill04: Loop 유지
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_Multi_Skill_R_Activate_Animation()
    {
        animator.SetTrigger("tSkill04");
        animator.SetBool("bSkill04", true);
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // RPC_Multi_Skill_R_Deactivate_Animation() - R 스킬 비활성화 (토글 OFF)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_Multi_Skill_R_Deactivate_Animation()
    {
        animator.SetBool("bSkill04", false);
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // RPC_Multi_BasicAttack() - 기본 공격 애니메이션
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_Multi_BasicAttack()
    {
        animator.SetTrigger("tBasicAttack");
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // RPC_Multi_CancelBasicAttack() - 기본 공격 캔슬 (이동 시 호출)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // 기본 공격 중 이동 명령 또는 스킬 사용 시 호출
    //
    // ResetTrigger():
    // - 아직 처리되지 않은 Trigger 취소
    // - 공격 모션이 시작되기 전이면 취소됨
    //
    // SetTrigger("tCancelAttack"):
    // - 캔슬용 트리거 (선택적)
    // - 애니메이션 State Machine에서 빠른 복귀 Transition으로 연결
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_Multi_CancelBasicAttack()
    {
        animator.ResetTrigger("tBasicAttack");
        animator.SetTrigger("tCancelAttack");  // 캔슬용 트리거 (선택적)
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // Phase 4: 스킬 애니메이션 캔슬 (Animation Canceling 동기화용)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // 왜 필요한가?
    // - 서버에서 캔슬이 발생하면 다른 클라이언트도 알아야 함
    // - 안 그러면 서버/클라이언트 애니메이션 타이밍이 다름
    // - 상대방 화면에서 내 캐릭터가 "버벅거림"
    //
    // 작동 방식:
    // 1. 서버에서 캔슬 발생 → 이 RPC 호출
    // 2. 모든 클라이언트에서 현재 스킬 애니메이션 즉시 중단
    // 3. 빠르게 Idle 또는 다음 스킬로 블렌딩
    //
    // ┌─────────────────────────────────────────────────────────────────────────────────────────────────┐
    // │ Animation Canceling 타임라인                                                                     │
    // │                                                                                                   │
    // │ [서버]                                                                                            │
    // │ 0ms ──────────────────────────────────────────────────────────> 시간                             │
    // │     ├─ Q 시전 ─┤─ 데미지 ─┤─ 캔슬! ─┤                                                             │
    // │     │          │          │        │                                                             │
    // │     │          │          └── RPC_Multi_CancelSkillAnimation() 호출                              │
    // │                                                                                                   │
    // │ [클라이언트A] (RPC 없을 때)                                                                       │
    // │     ├─ Q 시전 ─┤─ 데미지 ─┤─ 후딜레이 ─┤─ W 시작                                                  │
    // │                           └── 서버보다 늦게 W 시작! (타이밍 불일치)                               │
    // │                                                                                                   │
    // │ [클라이언트A] (RPC 있을 때)                                                                       │
    // │     ├─ Q 시전 ─┤─ 데미지 ─┤─ CrossFade ─┤─ W 시작                                                 │
    // │                           └── 서버와 동시에 W 시작! (타이밍 일치)                                 │
    // └─────────────────────────────────────────────────────────────────────────────────────────────────┘
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [Rpc(RpcSources.StateAuthority, RpcTargets.All, HostMode = RpcHostMode.SourceIsServer)]
    public void RPC_Multi_CancelSkillAnimation()
    {
        // ═══════════════════════════════════════════════════════════════
        // 현재 재생 중인 스킬 트리거 리셋
        //
        // ResetTrigger():
        // - 아직 처리되지 않은 Trigger 취소
        // - 이미 재생 중인 애니메이션에는 영향 없음
        // - 다만 Trigger가 큐에 남아있으면 취소됨
        // ═══════════════════════════════════════════════════════════════
        animator.ResetTrigger("tSkill01");
        animator.ResetTrigger("tSkill02");

        // ═══════════════════════════════════════════════════════════════
        // 빠른 블렌딩으로 자연스럽게 전환
        //
        // CrossFade(stateName, transitionDuration):
        // - 현재 애니메이션 → 목표 애니메이션을 부드럽게 연결
        // - transitionDuration: 전환 시간 (초)
        //
        // 0.05f = 50ms:
        // - 매우 빠른 전환 (거의 즉시)
        // - 너무 빠르면 뚝 끊기고, 너무 느리면 캔슬 느낌이 안 남
        // - 50ms는 경험적으로 적절한 값
        //
        // "Idle":
        // - 애니메이션 State 이름
        // - 기본 대기 상태로 복귀
        // - 이후 다음 스킬/이동 애니메이션으로 자연스럽게 연결
        // ═══════════════════════════════════════════════════════════════
        animator.CrossFade("Idle", 0.05f);
    }
}
