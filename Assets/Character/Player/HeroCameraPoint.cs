// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroCameraPoint.cs - 카메라 추적 포인트
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 개요 (Overview)                                                                                      │
// │                                                                                                       │
// │ 이 파일은 카메라가 추적할 포인트를 관리합니다.                                                        │
// │ 플레이어를 따라가되 Y축(높이)은 고정하여 안정적인 카메라 뷰를 제공합니다.                            │
// │                                                                                                       │
// │ 핵심 기술:                                                                                            │
// │ 1. LateUpdate - 플레이어 이동 후 카메라 포인트 업데이트                                               │
// │ 2. Fixed Y Position - 높이 고정으로 안정적인 뷰                                                      │
// │ 3. Distance Offset - 캐릭터 기준 오프셋 위치                                                         │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 설계 철학 (Design Philosophy)                                                                        │
// │                                                                                                       │
// │ Q: 왜 직접 카메라를 움직이지 않고 포인트를 사용하나요?                                               │
// │ A: Cinemachine이 포인트를 추적하게 하면:                                                               │
// │    - 부드러운 추적 (Cinemachine 자체 보간)                                                           │
// │    - 카메라 잠금/해제 쉬움 (TrackingTarget 설정/해제)                                                │
// │    - 카메라와 로직 분리 (Single Responsibility)                                                      │
// │                                                                                                       │
// │ Q: 왜 Y축을 고정하나요?                                                                               │
// │ A: MOBA 게임은 탑다운 뷰.                                                                             │
// │    캐릭터가 점프해도 카메라 높이가 변하면 어지러움.                                                   │
// │    고정된 높이에서 내려다보는 게 표준.                                                               │
// │                                                                                                       │
// │ Q: 왜 LateUpdate()를 사용하나요?                                                                     │
// │ A: Update 순서:                                                                                       │
// │    1. Update() - 입력 처리, 이동 로직                                                                 │
// │    2. LateUpdate() - 카메라, UI 업데이트                                                              │
// │    플레이어가 이동한 후에 카메라 포인트를 업데이트해야 떨림이 없음.                                   │
// │                                                                                                       │
// │ Q: DistanceOffset은 왜 있나요?                                                                       │
// │ A: 카메라 포인트가 캐릭터 정확히 위에 있으면:                                                         │
// │    - 캐릭터가 화면 정중앙에 위치                                                                      │
// │    - 오프셋으로 캐릭터를 화면 하단에 두면 전방 시야 확보                                              │
// │    - MOBA에서 보통 캐릭터는 화면 중앙~하단에 위치                                                     │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════

using System;
using Fusion;
using UnityEngine;

// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroCameraPoint 클래스
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// 역할:
// - 플레이어 위치를 따라가는 카메라 추적 포인트
// - Y축(높이) 고정으로 안정적인 뷰 제공
// - Cinemachine의 TrackingTarget으로 사용
//
// 오브젝트 구조:
// Player (Root)
//   ├── Model (캐릭터 메시)
//   ├── CameraPoint (이 스크립트 부착) ← Cinemachine이 추적
//   └── ...
//
// 관련 파일:
// - CameraController.cs: 이 포인트를 TrackingTarget으로 설정
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
public class HeroCameraPoint : MonoBehaviour
{
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // 설정 변수
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // player:
    // - 추적할 플레이어 Transform
    // - Inspector에서 할당
    //
    // FixedYPosition:
    // - 카메라 포인트의 고정 높이
    // - 9 = 지면에서 9유닛 위
    // - 카메라 각도에 따라 조정
    //
    // DistanceOffset:
    // - 플레이어 기준 오프셋
    // - (0, 0, 2) = 플레이어보다 앞쪽 (전방 시야 확보)
    // - (0, 0, -2) = 플레이어보다 뒤쪽
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    [SerializeField] private Transform player;

    [SerializeField] private float FixedYPosition = 9;

    [SerializeField] private Vector3 DistanceOffset;

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // InitPos() - 초기 위치 설정
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // 호출 시점:
    // - 플레이어 스폰 시 외부에서 호출
    // - 초기 카메라 위치 설정
    //
    // 파라미터 pos:
    // - 플레이어 초기 위치
    // - X, Z 좌표 사용, Y는 무시 (FixedYPosition 사용)
    //
    // 계산:
    // - X: pos.x + DistanceOffset.x
    // - Y: FixedYPosition (고정)
    // - Z: pos.z + DistanceOffset.z
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    public void InitPos(Vector3 pos)
    {
        Vector3 targetPosition = new Vector3(
            pos.x + DistanceOffset.x,
            FixedYPosition,
            pos.z + DistanceOffset.z
        );
        transform.position = targetPosition;
    }

    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // LateUpdate() - 플레이어 이동 후 위치 업데이트
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // LateUpdate vs Update:
    // - Update(): 모든 게임 로직, 이동 처리
    // - LateUpdate(): Update() 이후 실행
    //
    // 왜 LateUpdate()?
    // - 플레이어 이동이 Update()에서 완료된 후 카메라 포인트 업데이트
    // - Update()에서 하면 이동 전 위치를 참조할 수 있음
    // - 결과: 카메라가 1프레임 뒤처져 떨림 현상 발생
    //
    // 위치 계산:
    // - player.position.x + DistanceOffset.x
    // - FixedYPosition (고정, 플레이어 Y 무시)
    // - player.position.z + DistanceOffset.z
    //
    // null 체크:
    // - player가 파괴되거나 아직 할당 안 됐으면 스킵
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    private void LateUpdate()
    {
        if (player != null)
        {
            // 플레이어의 X, Z 좌표를 기반으로 카메라 위치를 업데이트하되, Y는 고정
            Vector3 targetPosition = new Vector3(
                player.position.x + DistanceOffset.x,
                FixedYPosition,
                player.position.z + DistanceOffset.z
            );
            transform.position = targetPosition;
        }
    }
}
