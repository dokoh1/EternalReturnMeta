// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroSkill.cs - 모든 영웅의 스킬 시스템 추상 클래스
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 개요 (Overview)                                                                                      │
// │                                                                                                       │
// │ 이 파일은 모든 영웅이 구현해야 하는 스킬 인터페이스를 정의합니다.                                     │
// │ abstract 클래스로 Q, W, E, R 스킬 메서드를 강제합니다.                                               │
// │                                                                                                       │
// │ 핵심 기술:                                                                                            │
// │ 1. abstract class - 인스턴스화 불가, 상속 강제                                                       │
// │ 2. abstract method - 자식 클래스에서 반드시 구현해야 함                                              │
// │ 3. Template Method 패턴 - 스킬 구조는 같고 내용만 다름                                               │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 설계 철학 (Design Philosophy)                                                                        │
// │                                                                                                       │
// │ Q: 왜 interface가 아닌 abstract class인가요?                                                         │
// │ A: NetworkBehaviour를 상속해야 하기 때문.                                                             │
// │    C#에서 클래스는 하나만 상속 가능 → abstract class + NetworkBehaviour                              │
// │    interface는 다중 구현 가능하지만, NetworkBehaviour 기능을 못 씀                                   │
// │                                                                                                       │
// │ Q: 왜 protected abstract인가요?                                                                      │
// │ A: protected: 외부에서 직접 스킬 호출 방지 (입력 시스템 통해서만)                                    │
// │    abstract: 자식 클래스에서 반드시 구현 강제                                                        │
// │    Eva_Skill에서 Skill_Q() 빠뜨리면 컴파일 에러 발생                                                 │
// │                                                                                                       │
// │ Q: 왜 스킬마다 별도 메서드인가요?                                                                    │
// │ A: 각 스킬이 완전히 다른 로직을 가질 수 있음                                                         │
// │    - Q: 투사체 발사                                                                                   │
// │    - W: 범위 공격                                                                                     │
// │    - E: 지속 버프                                                                                     │
// │    - R: 토글 스킬                                                                                     │
// │    하나의 메서드로 통합하면 조건문이 너무 복잡해짐                                                   │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
// │ 상속 구조 (Inheritance Hierarchy)                                                                    │
// │                                                                                                       │
// │ NetworkBehaviour (Fusion)                                                                            │
// │        │                                                                                              │
// │        └── HeroSkill (이 파일) [abstract]                                                             │
// │                 │                                                                                     │
// │                 ├── Eva_Skill  (Q: 투사체, W: 범위, E: 빛 발사, R: 토글)                             │
// │                 ├── Aya_Skill  (미래 캐릭터)                                                          │
// │                 └── Rio_Skill  (미래 캐릭터)                                                          │
// │                                                                                                       │
// │ 확장 예시:                                                                                            │
// │ - Eva_Skill은 Animation Canceling, Input Buffering 추가                                              │
// │ - 다른 캐릭터는 다른 전용 시스템 추가 가능                                                           │
// │ - 공통 로직(쿨다운 등)은 HeroSkill에 추가 가능                                                       │
// └─────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════

using Fusion;

// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
// HeroSkill 추상 클래스
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
//
// 역할:
// - 모든 영웅 스킬 클래스의 기본 구조 정의
// - Q, W, E, R 스킬 메서드 구현 강제
// - NetworkBehaviour 기능 제공 (RPC, [Networked] 등)
//
// 사용 예:
// public class Eva_Skill : HeroSkill
// {
//     protected override void Skill_Q() { /* Eva의 Q 스킬 구현 */ }
//     protected override void Skill_W() { /* Eva의 W 스킬 구현 */ }
//     protected override void Skill_E() { /* Eva의 E 스킬 구현 */ }
//     protected override void Skill_R() { /* Eva의 R 스킬 구현 */ }
// }
//
// 확장 가능성:
// - 쿨다운 시스템 (공통 로직)
// - 마나 시스템 (공통 로직)
// - 스킬 레벨업 시스템
// - 패시브 스킬 메서드 추가
//
// ═══════════════════════════════════════════════════════════════════════════════════════════════════════
public abstract class HeroSkill : NetworkBehaviour
{
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    // 스킬 추상 메서드
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    //
    // protected abstract:
    // - protected: 이 클래스와 자식 클래스에서만 접근 가능
    //   → 외부에서 skill.Skill_Q() 직접 호출 불가
    //   → 반드시 입력 시스템(HeroInput)을 통해 호출
    //
    // - abstract: 구현부 없음, 자식 클래스에서 반드시 override 필요
    //   → Eva_Skill에서 Skill_Q() 빠뜨리면 컴파일 에러:
    //   → "Eva_Skill does not implement inherited abstract member Skill_Q()"
    //
    // 왜 파라미터가 없나요?
    // - 현재는 단순화를 위해 파라미터 없음
    // - 스킬에 필요한 정보(타겟 위치, 대상 등)는
    //   자식 클래스에서 멤버 변수로 관리
    // - 추후 리팩토링 시 SkillContext 같은 구조체로 통일 가능
    //
    // 스킬 키 매핑:
    // - Skill_Q() ← Q키 (InputButton.SkillQ)
    // - Skill_W() ← W키 (InputButton.SkillW)
    // - Skill_E() ← E키 (InputButton.SkillE)
    // - Skill_R() ← R키 (InputButton.SkillR)
    // ═══════════════════════════════════════════════════════════════════════════════════════════════════
    protected abstract void Skill_Q();

    protected abstract void Skill_W();

    protected abstract void Skill_E();

    protected abstract void Skill_R();

}
